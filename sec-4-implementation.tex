
\chapter{Implementation}
\epigraph{The trouble with opportunity is that it always comes disguised as hard work.}%
{\textsc{---herbert v. prochnow}}

\begin{itemize}
    \item Accelerate frontend
        \begin{itemize}
            \item reification
                \begin{itemize}
                    \item smart constructors for type classes
                    \item explicit dictionaries (polymorphism)
                    \item environments
                    \item HOAS vs. de Bruijn
                    \item representation types
                \end{itemize}
            \item surface \& internal (core) languages
                \begin{itemize}
                    \item representing different constructs in surface/core
                    \item surface nested $\rightarrow$ core flat ?? (fuuuuture)
                \end{itemize}
            \item sharing observation ( --> sec 5? not my work )
        \end{itemize}

    \item Accelerate CUDA backend
        \begin{itemize}
            \item code generation
                \begin{itemize}
                    \item architecture sensitive JIT cross-compiler
                    \item future work: types, Haskell compile time
                \end{itemize}
            \item external compilation
                \begin{itemize}
                    \item annotating AST nodes
                \end{itemize}
            \item memory management
                \begin{itemize}
                    \item weak pointers \& weak hash tables
                    \item advantages to alternatives
                \end{itemize}
            \item execution
                \begin{itemize}
                    \item occupancy analysis
                    \item multi-pass kernels
                \end{itemize}
            \item performance
                \begin{itemize}
                    \item amortizing overheads (how to quantise this?)
                    \item of generated code
                    \item runtime overheads
                    \item w.r.t. CUDA memory subsystem (theoretical performance)
                    \item examples! spot the infelicities! (dot product)
                \end{itemize}
        \end{itemize}

\end{itemize}


The previous chapter described the design of the Accelerate language, an
embedded DSL of operations over arrays, rich enough to express some interesting
real-world problems. This chapter details the architecture of the embedding as
well as the implementation of a backend for parallel execution on CUDA hardware.

