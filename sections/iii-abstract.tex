
\chapter{Abstract}
\markboth{Abstract}{}

It is well acknowledged that the dominant mechanism for scaling processor
performance has become to increase the number of cores on a chip, rather than
improve the performance of a single core. However, harnessing these extra cores
to improve single application performance remains an extremely challenging task.
A recent trend has been to use commodity graphics processing units to explore
new algorithms and programming languages that can address the challenges of
parallelism and scalability for devices containing hundreds or thousands of
cores.

The research documented in this dissertation builds upon the \indexe{Accelerate}
language, an embedded domain specific language of purely functional collective
operations over dense, multidimensional arrays. Overall, this dissertation
explains how to efficiently implement such a language, ranging from
optimisations to the input program and the generation of efficient target code,
to optimisations in the runtime system which executes the resulting programs.

In particular, I add backend-agnostic optimisations to the embedded array
language, primarily in the form of a novel approach to array fusion. These
optimisations are completely type preserving, amounting to a partial proof of
correctness of the optimisations, checked by the type checker at compilation
time.

In addition, I develop the CUDA\cuda{} backend to Accelerate, which targets
parallel execution on multicore graphics processing units (GPUs)\gpu{}. I
implement a dynamic quasi quotation-based code generation system for algorithmic
skeletons that are instantiated at runtime. In order to minimise the overheads
of runtime compilation, generated codes are compiled in parallel and
asynchronously with other operations. Here, compiled binaries are cached for
later reuse, including across program invocations. As a significant overhead in
GPU programs is the transfer of data to and from the device, a garbage
collection-based memory management system was implemented which minimises data
transfers. Finally, I implement an execution engine that optimises the loading,
configuration, and concurrent execution of the compiled GPU kernels.

My results show that with these additions, programs written in Accelerate can
be competitive in performance to programs written in traditional lower-level
languages, while enjoying a much higher level of abstraction. Through the work
done in this thesis, Accelerate has become the dominant method for GPGPU\gpgpu{}
programming in Haskell.


% Computers are no longer getting faster. Instead, including multiple cores on a
% single chip has become the dominant mechanism for scaling processor performance,
% and the exponential growth in the number of cores on a single processor is
% expected to lead in a short time to mainstream computers containing hundreds of
% devices. Unfortunately, programming parallel computers is known to be an
% extremely challenging task, even for expert computer programmers.
%
% In order to achieve improved single-application performance on such processors,
% an appropriate programming model is needed which can expose parallelism and
% address scalability. Commodity graphics processing units, which have evolved
% into flexible general-purpose parallel architectures, can provide some insight
% into many of the challengers developers will face; finding parallelism within
% our applications to satiate available hardware, and rationalising the
% interactions of large numbers of concurrent threads.
%
% This thesis presents the design, implementation, and evaluation of a new
% domain--specific language embedded within Haskell for flat data-parallel array
% computations executed on graphics processing units. The design concentrates on
% providing a high--level abstraction that composes computations that run
% efficiently according to the strengths and weaknesses of the underlying
% hardware, without forcing the programmer to recast their algorithm to fit within
% that architecture.
%
% The main contribution of this thesis is an embedded language \emph{Accelerate},
% which is more expressive than previous languages targeting general purpose
% computations on graphics processors, while benchmarks show that programs in
% Accelerate can be competitive with those written in traditional lower-level
% languages. Through the work done in this thesis, Accelerate has become the
% dominant method for GPGPU programming in Haskell.

